type Query {
	#   Returns the authenticated user
	currentUser: User

	#   Returns an entrant given its id
	#
	# Arguments
	#   id: [Not documented]
	entrant(id: ID!): Entrant

	#   Returns an event given its id or slug
	#
	# Arguments
	#   id: [Not documented]
	#   slug: [Not documented]
	event(id: ID, slug: String): Event

	#   Returns a league given its id or slug
	#
	# Arguments
	#   id: [Not documented]
	#   slug: [Not documented]
	league(id: ID, slug: String): League

	#   Paginated, filterable list of leagues
	#
	# Arguments
	#   query: [Not documented]
	leagues(query: LeagueQuery!): LeagueConnection

	#   Returns a participant given its id
	#
	# Arguments
	#   id: [Not documented]
	#   isAdmin: [Not documented]
	participant(id: ID!, isAdmin: Boolean): Participant

	#   Returns a phase given its id
	#
	# Arguments
	#   id: [Not documented]
	phase(id: ID): Phase

	#   Returns a phase group given its id
	#
	# Arguments
	#   id: [Not documented]
	phaseGroup(id: ID): PhaseGroup

	#   Returns a player given an id
	#
	# Arguments
	#   id: [Not documented]
	player(id: ID!): Player

	#   Returns a phase seed given its id
	#
	# Arguments
	#   id: [Not documented]
	seed(id: ID): Seed

	#   Returns a set given its id
	#
	# Arguments
	#   id: [Not documented]
	set(id: ID!): Set

	#   A shop entity
	#
	# Arguments
	#   id: [Not documented]
	#   slug: [Not documented]
	shop(id: ID, slug: String): Shop

	#   Returns an stream given its id
	#
	# Arguments
	#   id: [Not documented]
	stream(id: ID!): Streams

	#   Returns all the stream queues for a given tournament
	#
	# Arguments
	#   tournamentId: [Not documented]
	#   includePlayerStreams: [Not documented]
	streamQueue(tournamentId: ID!, includePlayerStreams: Boolean): [StreamQueue]

	#   Returns a team given its id
	#
	# Arguments
	#   id: [Not documented]
	#   slug: [Not documented]
	#   inviteCode: [Not documented]
	team(id: ID, slug: String, inviteCode: String): Team

	#   Returns a tournament given its id or slug
	#
	# Arguments
	#   id: [Not documented]
	#   slug: [Not documented]
	tournament(id: ID, slug: String): Tournament

	#   Paginated, filterable list of tournaments
	#
	# Arguments
	#   query: [Not documented]
	tournaments(query: TournamentQuery!): TournamentConnection

	#   Returns a user given a user slug of the form user/abc123, or id
	#
	# Arguments
	#   id: [Not documented]
	#   slug: [Not documented]
	user(id: ID, slug: String): User

	#   Returns a videogame given its id
	#
	# Arguments
	#   id: [Not documented]
	#   slug: [Not documented]
	videogame(id: ID, slug: String): Videogame

	#   Returns paginated list of videogames matching the search criteria.
	#
	# Arguments
	#   query: [Not documented]
	videogames(query: VideogameQuery!): VideogameConnection
}

type Mutation {
	#   Delete a phase by id
	#
	# Arguments
	#   phaseId: [Not documented]
	deletePhase(phaseId: ID!): Boolean

	#   Delete a station by id
	#
	# Arguments
	#   stationId: [Not documented]
	deleteStation(stationId: ID!): Boolean

	#   Delete a wave by id
	#
	# Arguments
	#   waveId: [Not documented]
	deleteWave(waveId: ID!): Boolean

	#   Generate tournament registration Token on behalf of user
	#
	# Arguments
	#   registration: [Not documented]
	#   userId: [Not documented]
	generateRegistrationToken(registration: TournamentRegistrationInput!, userId: ID!): String

	#   Update a set to called state
	#
	# Arguments
	#   setId: [Not documented]
	markSetCalled(setId: ID!): Set

	#   Update a set to called state
	#
	# Arguments
	#   setId: [Not documented]
	markSetInProgress(setId: ID!): Set

	#   Register for tournament
	#
	# Arguments
	#   registration: [Not documented]
	#   registrationToken: [Not documented]
	registerForTournament(
		registration: TournamentRegistrationInput
		registrationToken: String
	): Participant

	#   Report set winner or game stats for a H2H bracket set. If winnerId is
	#   supplied, mark set as complete. gameData parameter will overwrite any existing
	#   reported game data.
	#
	# Arguments
	#   setId: [Not documented]
	#   winnerId: [Not documented]
	#   isDQ: [Not documented]
	#   gameData: [Not documented]
	reportBracketSet(
		setId: ID!
		winnerId: ID
		isDQ: Boolean
		gameData: [BracketSetGameDataInput]
	): [Set]

	#   Resets set to initial state, can affect other sets and phase groups
	#
	# Arguments
	#   setId: [Not documented]
	#   resetDependentSets: [Not documented]
	resetSet(setId: ID!, resetDependentSets: Boolean): Set

	#   Automatically attempt to resolve all schedule conflicts. Returns a list of
	#   changed seeds
	#
	# Arguments
	#   tournamentId: [Not documented]
	#   options: [Not documented]
	resolveScheduleConflicts(tournamentId: ID!, options: ResolveConflictsOptions): [Seed]

	#   Swap two seed ids in a phase
	#
	# Arguments
	#   phaseId: [Not documented]
	#   seed1Id: [Not documented]
	#   seed2Id: [Not documented]
	swapSeeds(phaseId: ID!, seed1Id: ID!, seed2Id: ID!): [Seed]

	#   Update game stats for a H2H bracket set. Set winner cannot be changed with
	#   this function, use the resetSet mutation instead.
	#
	# Arguments
	#   setId: [Not documented]
	#   winnerId: [Not documented]
	#   isDQ: [Not documented]
	#   gameData: [Not documented]
	updateBracketSet(
		setId: ID!
		winnerId: ID
		isDQ: Boolean
		gameData: [BracketSetGameDataInput]
	): Set

	#   Update set of phase groups in a phase
	#
	# Arguments
	#   groupConfigs: [Not documented]
	updatePhaseGroups(groupConfigs: [PhaseGroupUpdateInput]!): [PhaseGroup]

	#   Update the seeding for a phase
	#
	# Arguments
	#   phaseId: [Not documented]
	#   seedMapping: [Not documented]
	#   options: [Not documented]
	updatePhaseSeeding(
		phaseId: ID!
		seedMapping: [UpdatePhaseSeedInfo]!
		options: UpdatePhaseSeedingOptions
	): Phase

	#   Create or update a Phase
	#
	# Arguments
	#   phaseId: [Not documented]
	#   eventId: [Not documented]
	#   payload: [Not documented]
	upsertPhase(phaseId: ID, eventId: ID, payload: PhaseUpsertInput!): Phase

	#   Add or update a station by id
	#
	# Arguments
	#   stationId: [Not documented]
	#   tournamentId: [Not documented]
	#   fields: [Not documented]
	upsertStation(stationId: ID, tournamentId: ID, fields: StationUpsertInput!): Stations

	#   Add or update a wave by id
	#
	# Arguments
	#   waveId: [Not documented]
	#   tournamentId: [Not documented]
	#   fields: [Not documented]
	upsertWave(waveId: ID, tournamentId: ID, fields: WaveUpsertInput!): Wave
}

scalar Boolean

scalar Float

scalar ID

scalar Int

scalar JSON

scalar String

scalar Timestamp

enum ActivityState {
	#   Activity is created
	CREATED

	#   Activity is active or in progress
	ACTIVE

	#   Activity is done
	COMPLETED

	#   Activity is ready to be started
	READY

	#   Activity is invalid
	INVALID

	#   Activity, like a set, has been called to start
	CALLED

	#   Activity is queued to run
	QUEUED
}

enum AuthorizationType {
	TWITTER

	TWITCH

	STEAM

	DISCORD

	XBOX

	EPIC

	BATTLENET

	MIXER
}

enum BracketType {
	SINGLE_ELIMINATION

	DOUBLE_ELIMINATION

	ROUND_ROBIN

	SWISS

	EXHIBITION

	CUSTOM_SCHEDULE

	MATCHMAKING

	ELIMINATION_ROUNDS

	RACE

	CIRCUIT
}

enum Comparator {
	GREATER_THAN

	GREATER_THAN_OR_EQUAL

	EQUAL

	LESS_THAN_OR_EQUAL

	LESS_THAN
}

enum GameSelectionType {
	#   Character selection
	CHARACTER
}

enum MatchConfigVerificationMethod {
	TWITCH

	STREAM_ME

	ANY

	MIXER

	YOUTUBE
}

enum RaceLimitMode {
	BEST_ALL

	FIRST_ALL

	PLAYTIME
}

enum RaceType {
	GOALS

	TIMED
}

enum SetSortType {
	#   Sets will not be sorted.
	NONE

	#   Sets are sorted in the suggested order that they be called to be played. The
	#   order of completed sets is reversed.
	CALL_ORDER

	#   Sets are sorted by relevancy dependent on the state and progress of the event.
	MAGIC

	#   Sets are sorted in the order that they were started.
	RECENT

	#   Deprecated. This is equivalent to CALL_ORDER
	STANDARD

	#   Sets sorted by round and identifier
	ROUND
}

enum SocialConnectionType {
	TWITTER

	TWITCH

	DISCORD

	MIXER

	XBOX
}

enum StreamSource {
	#   Stream is on twitch.tv channel
	TWITCH

	#   Stream is on smashcast.tv channel
	HITBOX

	#   Stream is on a stream.me channel
	STREAMME

	#   Stream is on a mixer.com channel
	MIXER

	#   Stream is on a youtube.com channel
	YOUTUBE
}

enum StreamType {
	TWITCH

	MIXER

	YOUTUBE
}

enum TeamMemberStatus {
	UNKNOWN

	ACCEPTED

	INVITED

	REQUEST

	ALUM

	HIATUS

	OPEN_SPOT
}

enum TeamMemberType {
	PLAYER

	STAFF
}

enum TournamentPaginationSort {
	startAt

	endAt

	eventRegistrationClosesAt

	computedUpdatedAt
}

interface ActionSet {
	id: ID
}

interface BracketConfig {
	id: ID

	bracketType: BracketType
}

interface MatchConfig {
	id: ID

	bracketType: BracketType
}

interface Team {
	id: ID

	#   Uniquely identifying token for team. Same as the hashed part of the slug
	discriminator: String

	entrant: Entrant @deprecated(reason: "Use the entrant field off the EventTeam type")

	event: Event @deprecated(reason: "Use the event field off the EventTeam type")

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	# Arguments
	#   status: [Not documented]
	members(status: [TeamMemberStatus]): [TeamMember]

	name: String
}

union StandingContainer = Tournament | Event | PhaseGroup | Set

type Address {
	id: ID

	city: String

	country: String

	countryId: Int

	state: String

	stateId: Int
}

type Character {
	id: ID

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	#   Name of Character
	name: String
}

type ContactInfo {
	id: ID

	#   Participant City Name
	city: String

	#   Participant Country Name
	country: String

	#   Participant Country (region) id
	countryId: Int

	name: String

	#   First Name
	nameFirst: String

	#   Last Name
	nameLast: String

	#   Participant State Name
	state: String

	#   Participant State (region) id
	stateId: Int

	#   Zip or Postal Code
	zipcode: String
}

type Entrant {
	id: ID

	event: Event

	#   Entrant's seed number in the first phase of the event.
	initialSeedNum: Int

	isDisqualified: Boolean

	#   The entrant name as it appears in bracket: gamerTag of the participant or team
	#   name
	name: String

	#   Paginated sets for this entrant
	#
	# Arguments
	#   page: [Not documented]
	#   perPage: [Not documented]
	#   sortType: How to sort these sets
	#   filters: Supported filter options to filter down set results.
	paginatedSets(page: Int, perPage: Int, sortType: SetSortType, filters: SetFilters): SetConnection

	participants: [Participant]

	seeds: [Seed]

	skill: Int

	#   Standing for this entrant given an event. All entrants queried must be in the
	#   same event (for now).
	standing: Standing

	stream: Streams
		@deprecated(
			reason: "DEPRECATED. Use streams instead, which supports multiple stream types and teams."
		)

	streams: [Streams]

	#   Team linked to this entrant, if one exists
	team: Team
}

type EntrantConnection {
	pageInfo: PageInfo

	nodes: [Entrant]
}

type Event {
	id: ID

	#   How long before the event start will the check-in end (in seconds)
	checkInBuffer: Int

	#   How long the event check-in will last (in seconds)
	checkInDuration: Int

	#   Whether check-in is enabled for this event
	checkInEnabled: Boolean

	#   Rough categorization of event tier, denoting relative importance in the
	#   competitive scene
	competitionTier: Int

	#   When the event was created (unix timestamp)
	createdAt: Timestamp

	#   Last date attendees are able to create teams for team events
	deckSubmissionDeadline: Timestamp

	#   Maximum number of participants each Entrant can have
	entrantSizeMax: Int @deprecated(reason: "Migrate to teamRosterSize")

	#   Minimum number of participants each Entrant can have
	entrantSizeMin: Int @deprecated(reason: "Migrate to teamRosterSize")

	#   The entrants that belong to an event, paginated by filter criteria
	#
	# Arguments
	#   query: [Not documented]
	entrants(query: EventEntrantPageQuery): EntrantConnection

	#   Whether the event has decks
	hasDecks: Boolean

	#   Are player tasks enabled for this event
	hasTasks: Boolean

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	#   Whether the event is an online event or not
	isOnline: Boolean

	league: League

	#   Markdown field for match rules/instructions
	matchRulesMarkdown: String

	#   Title of event set by organizer
	name: String

	#   Gets the number of entrants in this event
	numEntrants: Int

	#   The phase groups that belong to an event.
	phaseGroups: [PhaseGroup]

	#   The phases that belong to an event.
	#
	# Arguments
	#   state: Filter phases by state. If not specified will default to
	#   all phases
	#   phaseId: Optionally only return results for this phase
	phases(state: ActivityState, phaseId: ID): [Phase]

	#   TO settings for prizing
	prizingInfo: JSON

	publishing: JSON

	#   Markdown field for event rules/instructions
	rulesMarkdown: String

	#   Id of the event ruleset
	rulesetId: Int

	#   Settings pulled from the event ruleset, if one exists
	rulesetSettings: JSON @deprecated(reason: "Use ruleset")

	#   Paginated sets for this Event
	#
	# Arguments
	#   page: [Not documented]
	#   perPage: [Not documented]
	#   sortType: How to sort these sets
	#   filters: Supported filter options to filter down set results.
	sets(page: Int, perPage: Int, sortType: SetSortType, filters: SetFilters): SetConnection

	slug: String

	#   Paginated list of standings
	#
	# Arguments
	#   query: [Not documented]
	standings(query: StandingPaginationQuery!): StandingConnection

	#   When does this event start?
	startAt: Timestamp

	#   The state of the Event.
	state: ActivityState

	#   Paginated stations on this event
	#
	# Arguments
	#   query: [Not documented]
	stations(query: StationFilter): StationsConnection

	#   Last date attendees are able to create teams for team events
	teamManagementDeadline: Timestamp

	#   If this is a teams event, returns whether or not teams can set custom names
	teamNameAllowed: Boolean

	#   Team roster size requirements
	teamRosterSize: TeamRosterSize

	tournament: Tournament

	#   The type of the event, whether an entrant will have one participant or multiple
	type: Int

	#   When the event was last modified (unix timestamp)
	updatedAt: Timestamp

	#   Whether the event uses the new EventSeeds for seeding
	useEventSeeds: Boolean

	#   The entrant (if applicable) for a given user in this event
	#
	# Arguments
	#   userId: User to get entrant for. Defaults to currently logged
	#   in user.
	userEntrant(userId: ID): Entrant

	videogame: Videogame

	#   The waves being used by the event
	#
	# Arguments
	#   phaseId: Waves filtered by phaseId, returns all if not set.
	waves(phaseId: ID): [Wave]
}

type EventConnection {
	pageInfo: PageInfo

	nodes: [Event]
}

type EventOwner {
	eventId: ID

	email: String

	gamerTag: String

	fullName: String
}

type EventOwnerConnection {
	pageInfo: PageInfo

	nodes: [EventOwner]
}

type EventTeam implements Team {
	id: ID

	#   Uniquely identifying token for team. Same as the hashed part of the slug
	discriminator: String

	entrant: Entrant @deprecated(reason: "Use the entrant field off the EventTeam type")

	event: Event @deprecated(reason: "Use the event field off the EventTeam type")

	globalTeam: GlobalTeam

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	# Arguments
	#   status: [Not documented]
	members(status: [TeamMemberStatus]): [TeamMember]

	name: String
}

type EventTeamConnection {
	pageInfo: PageInfo

	nodes: [EventTeam]
}

type EventTier {
	id: ID

	#   Name of this tier
	name: String
}

type Game {
	id: ID

	#   Score of entrant 1. For smash, this is equivalent to stocks remaining.
	entrant1Score: Int

	#   Score of entrant 2. For smash, this is equivalent to stocks remaining.
	entrant2Score: Int

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	orderNum: Int

	#   Selections for this game such as character, etc.
	selections: [GameSelection]

	#   The stage that this game was played on (if applicable)
	stage: Stage

	state: Int

	winnerId: Int
}

type GameSelection {
	#   If this is a character selection, returns the selected character.
	character: Character

	id: ID

	#   The entrant who this selection is for
	entrant: Entrant

	orderNum: Int

	#   The participant who this selection is for. This is only populated if there are
	#   selections for multiple participants of a single entrant
	participant: Participant

	selectionType: GameSelectionType

	selectionValue: Int
}

type GlobalTeam implements Team {
	id: ID

	#   Uniquely identifying token for team. Same as the hashed part of the slug
	discriminator: String

	entrant: Entrant @deprecated(reason: "Use the entrant field off the EventTeam type")

	event: Event @deprecated(reason: "Use the event field off the EventTeam type")

	# Arguments
	#   query: [Not documented]
	eventTeams(query: TeamPaginationQuery): EventTeamConnection

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	#   Leagues-level teams for leagues this team is competing in
	#
	# Arguments
	#   query: [Not documented]
	leagueTeams(query: TeamPaginationQuery): EventTeamConnection

	# Arguments
	#   status: [Not documented]
	members(status: [TeamMemberStatus]): [TeamMember]

	name: String
}

type Image {
	id: ID

	height: Float

	ratio: Float

	type: String

	url: String

	width: Float
}

type League {
	id: ID

	addrState: String

	city: String

	countryCode: String

	#   When the tournament was created (unix timestamp)
	createdAt: Timestamp

	currency: String

	#   When the tournament ends
	endAt: Timestamp

	entrantCount: Int

	# Arguments
	#   query: [Not documented]
	eventOwners(query: EventOwnersQuery): EventOwnerConnection

	#   When does event registration close
	eventRegistrationClosesAt: Timestamp

	#   Paginated list of events in a league
	#
	# Arguments
	#   query: [Not documented]
	events(query: LeagueEventsQuery): EventConnection

	#   Hacked "progression" into this final event
	finalEventId: Int @deprecated(reason: "No longer used")

	#   True if tournament has at least one offline event
	hasOfflineEvents: Boolean

	hasOnlineEvents: Boolean

	hashtag: String

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	#   True if tournament has at least one online event
	isOnline: Boolean

	lat: Float

	links: TournamentLinks

	lng: Float

	mapsPlaceId: String

	#   The tournament name
	name: String

	#   Top X number of people in the standings who progress to final event
	numProgressingToFinalEvent: Int @deprecated(reason: "No longer used")

	numUniquePlayers: Int

	postalCode: String

	primaryContact: String

	primaryContactType: String

	#   Publishing settings for this tournament
	publishing: JSON

	#   When does registration for the tournament end
	registrationClosesAt: Timestamp

	rules: String

	#   The short slug used to form the url
	shortSlug: String

	#   Whether standings for this league should be visible
	showStandings: Boolean

	slug: String

	#   Paginated list of standings
	#
	# Arguments
	#   query: [Not documented]
	standings(query: StandingGroupStandingPageFilter): StandingConnection

	#   When the tournament Starts
	startAt: Timestamp

	#   State of the tournament, can be ActivityState::CREATED, ActivityState::ACTIVE,
	#   or ActivityState::COMPLETED
	state: Int

	#   When is the team creation deadline
	teamCreationClosesAt: Timestamp

	tiers: [EventTier]

	#   The timezone of the tournament
	timezone: String

	#   The type of tournament from TournamentType
	tournamentType: Int

	#   When the tournament was last modified (unix timestamp)
	updatedAt: Timestamp

	#   Build Tournament URL
	#
	# Arguments
	#   tab: Tournament tab to add to URL
	#   relative: Generate a relative URL. Defaults to true. Setting to
	#   false will generate an absolute URL
	url(tab: String, relative: Boolean): String

	venueAddress: String

	venueName: String

	videogames: [Videogame]
}

type LeagueConnection {
	pageInfo: PageInfo

	nodes: [League]
}

type PageInfo {
	total: Int

	totalPages: Int

	page: Int

	perPage: Int

	sortBy: String

	filter: JSON
}

type Participant {
	id: ID

	#   If this participant was checked-in by admin
	checkedIn: Boolean

	#   The time this participant was checked-in by admin
	checkedInAt: Timestamp

	#   Info for connected accounts to external services.
	connectedAccounts: JSON

	#   Contact Info selected during registration. Falls back to User.location and/or
	#   User.name if necessary. These fields are for admin use only. If you are not a
	#   tournament admin or the participant being queried, these fields will be null.
	#   Do not display this information publicly.
	contactInfo: ContactInfo

	#   Email of the user, only available to admins within 18 months of tournament
	#   completion for tournament administrators.
	email: String

	#   Entrants associated with this Participant, if applicable
	entrants: [Entrant]

	#   The events this participant registered for within a Tournament.
	events: [Event]

	#   The tag that was used when the participant registered, e.g. Mang0
	gamerTag: String

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	player: Player

	#   The prefix that the user set for this Tournament, e.g. C9
	prefix: String

	#   Tournament Admin viewable field. Shows details for required social connections
	requiredConnections: [ProfileAuthorization]

	#   The user this participant is associated to.
	user: User

	#   If this participant is verified as actually being in the tournament
	verified: Boolean
}

type ParticipantConnection {
	pageInfo: PageInfo

	nodes: [Participant]
}

type Phase {
	id: ID

	#   The bracket type of this phase.
	bracketType: BracketType

	#   The Event that this phase belongs to
	event: Event

	#   Number of phase groups in this phase
	groupCount: Int

	#   Is the phase an exhibition or not.
	isExhibition: Boolean

	#   Name of phase e.g. Round 1 Pools
	name: String

	#   The number of seeds this phase contains.
	numSeeds: Int

	# Arguments
	#   query: [Not documented]
	#   eventId: [Not documented]
	paginatedSeeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection
		@deprecated(reason: "Please use 'seeds' instead")

	#   Phase groups under this phase, paginated
	#
	# Arguments
	#   query: [Not documented]
	phaseGroups(query: PhaseGroupPageQuery): PhaseGroupConnection

	#   The relative order of this phase within an event
	phaseOrder: Int

	#   Paginated seeds for this phase
	#
	# Arguments
	#   query: [Not documented]
	#   eventId: [Not documented]
	seeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection

	#   Paginated sets for this Phase
	#
	# Arguments
	#   page: [Not documented]
	#   perPage: [Not documented]
	#   sortType: How to sort these sets
	#   filters: Supported filter options to filter down set results.
	sets(page: Int, perPage: Int, sortType: SetSortType, filters: SetFilters): SetConnection

	#   State of the phase
	state: ActivityState

	waves: [Wave]
}

type PhaseGroup {
	id: ID

	#   The bracket type of this group's phase.
	bracketType: BracketType

	#   URL for this phase groups's bracket.
	bracketUrl: String

	#   Unique identifier for this group within the context of its phase
	displayIdentifier: String

	#   For the given phase group, this is the start time of the first round that occurs
	#   in the group.
	firstRoundTime: Timestamp

	numRounds: Int

	# Arguments
	#   query: [Not documented]
	#   eventId: [Not documented]
	paginatedSeeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection
		@deprecated(reason: "Please use 'seeds', which is now paginated")

	#   Paginated sets on this phaseGroup
	#
	# Arguments
	#   page: [Not documented]
	#   perPage: [Not documented]
	#   sortType: How to sort these sets
	#   filters: Supported filter options to filter down set results.
	paginatedSets(page: Int, perPage: Int, sortType: SetSortType, filters: SetFilters): SetConnection
		@deprecated(reason: "Please use 'sets', which is now paginated")

	#   The phase associated with this phase group
	phase: Phase

	#   The progressions out of this phase group
	progressionsOut: [Progression]

	rounds: [Round]

	seedMap: JSON

	#   Paginated seeds for this phase group
	#
	# Arguments
	#   query: [Not documented]
	#   eventId: [Not documented]
	seeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection

	#   Paginated sets on this phaseGroup
	#
	# Arguments
	#   page: [Not documented]
	#   perPage: [Not documented]
	#   sortType: How to sort these sets
	#   filters: Supported filter options to filter down set results.
	sets(page: Int, perPage: Int, sortType: SetSortType, filters: SetFilters): SetConnection

	#   Paginated list of standings
	#
	# Arguments
	#   query: [Not documented]
	standings(query: StandingGroupStandingPageFilter): StandingConnection

	#   Unix time the group is scheduled to start. This info could also be on the wave
	#   instead.
	startAt: Timestamp

	state: Int

	tiebreakOrder: JSON

	wave: Wave
}

type PhaseGroupConnection {
	pageInfo: PageInfo

	nodes: [PhaseGroup]
}

type Player {
	id: ID

	gamerTag: String

	prefix: String

	#   Most recent active & published rankings
	#
	# Arguments
	#   limit: [Not documented]
	#   videogameId: [Not documented]
	rankings(limit: Int, videogameId: ID): [PlayerRank]

	#   Recent sets for this player.
	#
	# Arguments
	#   opponentId: Use this to get H2H history between two players
	recentSets(opponentId: ID): [Set] @deprecated(reason: "Use the sets field instead.")

	#   Recent standings
	#
	# Arguments
	#   videogameId: [Not documented]
	#   limit: Number of recent standings to fetch. Default value is 3.
	#   Maximum value is 20.
	recentStandings(videogameId: ID, limit: Int): [Standing]

	#   Set history for this player.
	#
	# Arguments
	#   page: [Not documented]
	#   perPage: [Not documented]
	#   filters: Supported filter options to filter down set results.
	sets(page: Int, perPage: Int, filters: SetFilters): SetConnection

	user: User
}

type PlayerRank {
	id: ID

	#   The player's placement on the ranking
	rank: Int

	title: String
}

type ProfileAuthorization {
	id: ID

	#   The id given by the external service
	externalId: String

	#   The username given by the external service (including discriminator if discord)
	externalUsername: String

	stream: Stream

	#   The name of the external service providing this auth i.e. "twitch"
	type: AuthorizationType

	url: String
}

type Progression {
	id: ID

	originOrder: Int

	originPhase: Phase

	originPhaseGroup: PhaseGroup

	originPlacement: Int
}

type RaceBracketConfig implements BracketConfig {
	automaticEndTime: Timestamp

	id: ID

	automaticStartTime: Timestamp

	bracketType: BracketType

	goalTargetComparator: Comparator

	goalTargetValue: String

	limitMode: RaceLimitMode

	limitValue: Int

	raceType: RaceType
}

type RaceMatchConfig implements MatchConfig {
	id: ID

	bracketType: BracketType

	#   Can players report results?
	playerReportingEnabled: Boolean

	#   Accepted methods of verification that players can use
	verificationMethods: [MatchConfigVerificationMethod]

	#   Are players required to submit verification of their reported results?
	verificationRequired: Boolean
}

type ResetAffectedData {
	affectedSetCount: Int

	affectedSets: [Set]

	affectedPhaseGroupCount: Int
}

type Round {
	id: ID

	#   If applicable, bestOf is the number of games
	#
	#   one must win a majority out of to win a set in this round
	bestOf: Int

	#   Indicates this round's order in the phase group
	number: Int

	#   The time that this round is scheduled to start at
	startAt: Timestamp
}

type Score {
	#   The name of this score. e.g. "Kills" or "Stocks"
	label: String

	#   The raw score value
	value: Float

	#   Like value, but formatted for race format events. Formatted according to the
	#   race config for the front end to use.
	displayValue: String
}

type Seed {
	id: ID

	#   Map of Participant ID to checked in boolean
	checkedInParticipants: JSON

	entrant: Entrant

	groupSeedNum: Int

	isBye: Boolean

	phase: Phase

	phaseGroup: PhaseGroup

	placeholderName: String

	placement: Int

	#   The player(s) associated with this seed's entrant
	players: [Player]

	progressionSeedId: Int

	#   Source progression information
	progressionSource: Progression

	seedNum: Int

	#   Entrant's win/loss record for this standing. Scores do not include byes.
	#
	# Arguments
	#   phaseGroupId: [Not documented]
	setRecordWithoutByes(phaseGroupId: ID!): JSON

	# Arguments
	#   containerType: The container of the standing groups to get
	#   standings for. If null, will return all standings.
	standings(containerType: String): [Standing]
}

type SeedConnection {
	pageInfo: PageInfo

	nodes: [Seed]
}

type Set {
	id: ID

	#   The time this set was marked as completed
	completedAt: Timestamp

	#   The time this set was created
	createdAt: Timestamp

	# Arguments
	#   mainEntrantId: [Not documented]
	displayScore(mainEntrantId: ID): String

	#   Event that this set belongs to.
	event: Event

	#   Full round text of this set.
	fullRoundText: String

	# Arguments
	#   orderNum: [Not documented]
	game(orderNum: Int!): Game

	games: [Game]

	#   Whether this set contains a placeholder entrant
	hasPlaceholder: Boolean

	#   The letters that describe a unique identifier within the pool. Eg. F, AT
	identifier: String

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	lPlacement: Int

	#   Phase group that this Set belongs to.
	phaseGroup: PhaseGroup

	#   The sets that are affected from resetting this set
	resetAffectedData: ResetAffectedData

	#   The round number of the set. Negative numbers are losers bracket
	round: Int

	#   Indicates whether the set is in best of or total games mode. This instructs
	#   which field is used to figure out how many games are in this set.
	setGamesType: Int

	#   A possible spot in a set. Use this to get all entrants in a set. Use this for
	#   all bracket types (FFA, elimination, etc)
	#
	# Arguments
	#   includeByes: [Not documented]
	slots(includeByes: Boolean): [SetSlot]

	#   The start time of the Set. If there is no startAt time on the Set, will pull it
	#   from phaseGroup rounds configuration.
	startAt: Timestamp

	startedAt: Timestamp

	state: Int

	#   Tournament event station for a set
	station: Stations

	#   Tournament event stream for a set
	stream: Streams

	#   If setGamesType is in total games mode, this defined the number of games in the
	#   set.
	totalGames: Int

	#   Url of a VOD for this set
	vodUrl: String

	wPlacement: Int

	winnerId: Int
}

type SetConnection {
	pageInfo: PageInfo

	nodes: [Set]
}

type SetSlot {
	id: ID

	entrant: Entrant

	#   Pairs with prereqType, is the ID of the prereq.
	prereqId: String

	#   Given a set prereq type, defines the placement required in the origin set to end
	#   up in this slot.
	prereqPlacement: Int

	#   Describes where the entity in this slot comes from.
	prereqType: String

	seed: Seed

	#   The index of the slot. Unique per set.
	slotIndex: Int

	#   The standing within this set for the seed currently assigned to this slot.
	standing: Standing
}

type Shop {
	id: ID

	# Arguments
	#   query: [Not documented]
	levels(query: ShopLevelsQuery): ShopLevelConnection

	# Arguments
	#   query: [Not documented]
	messages(query: ShopOrderMessagesQuery): ShopOrderMessageConnection

	name: String

	slug: String

	url: String
}

type ShopLevel {
	id: ID

	currAmount: Float

	description: String

	goalAmount: Float

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	name: String
}

type ShopLevelConnection {
	pageInfo: PageInfo

	nodes: [ShopLevel]
}

type ShopOrderMessage {
	id: ID

	#   The player's gamertag. Returns null if anonymous message type
	gamertag: String

	#   The order message
	message: String

	#   The player's name. Returns null unless name & tag display is selected
	name: String

	#   The player who left the comment
	player: Player

	#   The total order amount
	total: Float
}

type ShopOrderMessageConnection {
	pageInfo: PageInfo

	nodes: [ShopOrderMessage]
}

type Stage {
	id: ID

	#   Stage name
	name: String
}

type Standing {
	id: ID

	#   The containing entity that contextualizes this standing. Event standings, for
	#   example, represent an entrant's standing in the entire event vs. Set standings
	#   which is an entrant's standing in only a single set within an event.
	container: StandingContainer

	#   If the entity this standing is assigned to can be resolved into an entrant, this
	#   will provide the entrant.
	entrant: Entrant

	isFinal: Boolean

	#   Metadata that goes along with this standing. Can take on different forms based
	#   on standing group type and settings.
	metadata: JSON

	placement: Int

	#   The player(s) tied to this standing's entity
	player: Player

	standing: Int
		@deprecated(reason: "The 'placement' field is identical and will eventually replace 'standing'")

	stats: StandingStats

	totalPoints: Float
}

type StandingConnection {
	pageInfo: PageInfo

	nodes: [Standing]
}

type StandingStats {
	score: Score
}

type Stations {
	id: ID

	canAutoAssign: Boolean

	clusterNumber: String

	clusterPrefix: Int

	enabled: Boolean

	identifier: Int

	numSetups: Int

	number: Int

	prefix: String

	queue: JSON

	queueDepth: Int

	state: Int

	updatedAt: Timestamp
}

type StationsConnection {
	pageInfo: PageInfo

	nodes: [Stations]
}

type Stream {
	id: ID

	#   Whether the stream is currently live. May be slightly delayed.
	isOnline: Boolean

	#   The name of the stream
	name: String

	#   The name of the external service providing this auth i.e. "twitch"
	type: StreamType
}

type StreamQueue {
	id: String

	#   The sets on the stream
	sets: [Set]

	#   The stream on the queue
	stream: Streams
}

type Streams {
	id: ID

	enabled: Boolean

	followerCount: Int

	isOnline: Boolean

	numSetups: Int

	parentStreamId: Int

	streamGame: String

	streamId: String

	streamLogo: String

	streamName: String

	streamSource: StreamSource

	streamStatus: String

	streamType: Int

	streamTypeId: Int
}

type TeamActionSet implements ActionSet {
	id: ID
}

type TeamConnection {
	pageInfo: PageInfo

	nodes: [Team]
}

type TeamMember {
	id: ID

	isAlternate: Boolean

	isCaptain: Boolean

	#   The type of the team member
	memberType: TeamMemberType

	participant: Participant

	player: Player

	#   The status of the team member
	status: TeamMemberStatus
}

type TeamRosterSize {
	maxAlternates: Int

	maxPlayers: Int

	minAlternates: Int

	minPlayers: Int
}

type Tournament {
	id: ID

	addrState: String

	#   Admin-only view of admins for this tournament
	#
	# Arguments
	#   roles: Which roles to show
	admins(roles: [String]): [User]

	city: String

	countryCode: String

	#   When the tournament was created (unix timestamp)
	createdAt: Timestamp

	currency: String

	#   When the tournament ends
	endAt: Timestamp

	#   When does event registration close
	eventRegistrationClosesAt: Timestamp

	# Arguments
	#   limit: [Not documented]
	#   filter: [Not documented]
	events(limit: Int, filter: EventFilter): [Event]

	#   True if tournament has at least one offline event
	hasOfflineEvents: Boolean

	hasOnlineEvents: Boolean

	hashtag: String

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	#   True if tournament has at least one online event
	isOnline: Boolean

	#   Is tournament registration open
	isRegistrationOpen: Boolean

	lat: Float

	links: TournamentLinks

	lng: Float

	mapsPlaceId: String

	#   The tournament name
	name: String

	#   Number of attendees including spectators, if public
	numAttendees: Int

	#   The user who created the tournament
	owner: User

	#   Paginated, queryable list of participants
	#
	# Arguments
	#   query: [Not documented]
	#   isAdmin: [Not documented]
	participants(query: ParticipantPaginationQuery!, isAdmin: Boolean): ParticipantConnection

	postalCode: String

	primaryContact: String

	primaryContactType: String

	#   Publishing settings for this tournament
	publishing: JSON

	#   When does registration for the tournament end
	registrationClosesAt: Timestamp

	rules: String

	#   The short slug used to form the url
	shortSlug: String

	#   The slug used to form the url
	slug: String

	#   When the tournament Starts
	startAt: Timestamp

	#   State of the tournament, can be ActivityState::CREATED, ActivityState::ACTIVE,
	#   or ActivityState::COMPLETED
	state: Int

	# Arguments
	#   page: [Not documented]
	#   perPage: [Not documented]
	stations(page: Int, perPage: Int): StationsConnection

	streamQueue: [StreamQueue]

	streams: [Streams]

	#   When is the team creation deadline
	teamCreationClosesAt: Timestamp

	#   Paginated, queryable list of teams
	#
	# Arguments
	#   query: [Not documented]
	teams(query: TeamPaginationQuery!): TeamConnection

	#   The timezone of the tournament
	timezone: String

	#   The type of tournament from TournamentType
	tournamentType: Int

	#   When the tournament was last modified (unix timestamp)
	updatedAt: Timestamp

	#   Build Tournament URL
	#
	# Arguments
	#   tab: Tournament tab to add to URL
	#   relative: Generate a relative URL. Defaults to true. Setting to
	#   false will generate an absolute URL
	url(tab: String, relative: Boolean): String

	venueAddress: String

	venueName: String

	#   List of all waves in this tournament
	waves: [Wave]
}

type TournamentConnection {
	pageInfo: PageInfo

	nodes: [Tournament]
}

type TournamentLinks {
	facebook: String

	discord: String
}

type User {
	#   Authorizations to external services (i.e. Twitch, Twitter)
	#
	# Arguments
	#   types: [Not documented]
	authorizations(types: [SocialConnectionType]): [ProfileAuthorization]

	id: ID

	bio: String

	#   Public facing user birthday that respects user publishing settings
	birthday: String

	#   Uniquely identifying token for user. Same as the hashed part of the slug
	discriminator: String

	email: String

	#   Events this user has competed in
	#
	# Arguments
	#   query: [Not documented]
	events(query: UserEventsPaginationQuery): EventConnection

	genderPronoun: String

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	#   Leagues this user has competed in
	#
	# Arguments
	#   query: [Not documented]
	leagues(query: UserLeaguesPaginationQuery): LeagueConnection

	#   Public location info for this user
	location: Address

	#   Public facing user name that respects user publishing settings
	name: String

	#   player for user
	player: Player

	slug: String

	#   Tournaments this user is organizing or competing in
	#
	# Arguments
	#   query: [Not documented]
	tournaments(query: UserTournamentsPaginationQuery): TournamentConnection
}

type Videogame {
	id: ID

	#   All characters for this videogame
	characters: [Character]

	displayName: String

	# Arguments
	#   type: [Not documented]
	images(type: String): [Image]

	name: String

	slug: String

	#   All stages for this videogame
	stages: [Stage]
}

type VideogameConnection {
	pageInfo: PageInfo

	nodes: [Videogame]
}

type Wave {
	id: ID

	#   The Wave Identifier
	identifier: String

	#   Unix time the wave is scheduled to start.
	startAt: Timestamp
}

input BracketSetGameDataInput {
	#   Entrant ID of game winnerwinnerId: ID
	#   Entrant ID of game winner
	winnerId: ID
	#   Game numbergameNum: Int!
	#   Game number
	gameNum: Int!
	#   Score for entrant 1 (if applicable). For smash, this is stocks remaining.entrant1Score: Int
	#   Score for entrant 1 (if applicable). For smash, this is stocks remaining.
	entrant1Score: Int
	#   Score for entrant 2 (if applicable). For smash, this is stocks remaining.entrant2Score: Int
	#   Score for entrant 2 (if applicable). For smash, this is stocks remaining.
	entrant2Score: Int
	#   ID of the stage that was played for this game (if applicable)stageId: ID
	#   ID of the stage that was played for this game (if applicable)
	stageId: ID
	#   List of selections for the game, typically character selections.selections: [BracketSetGameSelectionInput]
	#   List of selections for the game, typically character selections.
	selections: [BracketSetGameSelectionInput]
}

input BracketSetGameSelectionInput {
	#   Entrant ID that made selectionentrantId: ID!
	#   Entrant ID that made selection
	entrantId: ID!
	#   Character selected by this entrant for this game.characterId: Int
	#   Character selected by this entrant for this game.
	characterId: Int
}

input EventEntrantPageQuery {
	page: Int
	page: Int
	perPage: Int
	perPage: Int
	sortBy: String
	sortBy: String
	filter: EventEntrantPageQueryFilter
	filter: EventEntrantPageQueryFilter
}

input EventEntrantPageQueryFilter {
	name: String
	name: String
}

input EventFilter {
	videogameId: [ID]
	videogameId: [ID]
	type: [Int]
	type: [Int]
	published: Boolean
	published: Boolean
	id: ID
	id: ID
	ids: [ID]
	ids: [ID]
	slug: String
	slug: String
	fantasyEventId: ID
	fantasyEventId: ID
	fantasyRosterHash: String
	fantasyRosterHash: String
}

input EventOwnersQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
}

input LeagueEventsFilter {
	search: PaginationSearchType
	search: PaginationSearchType
	pointMappingGroupIds: [ID]
	pointMappingGroupIds: [ID]
	tierIds: [ID]
	tierIds: [ID]
	userId: ID
	userId: ID
	upcoming: Boolean
	upcoming: Boolean
	leagueEntrantId: ID
	leagueEntrantId: ID
}

input LeagueEventsQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: LeagueEventsFilter
	filter: LeagueEventsFilter
}

input LeaguePageFilter {
	id: ID
	id: ID
	ids: [ID]
	ids: [ID]
	#   ID of the user that owns this league.ownerId: ID
	#   ID of the user that owns this league.
	ownerId: ID
	afterDate: Timestamp
	afterDate: Timestamp
	beforeDate: Timestamp
	beforeDate: Timestamp
	computedUpdatedAt: Timestamp
	computedUpdatedAt: Timestamp
	name: String
	name: String
	isFeatured: Boolean
	isFeatured: Boolean
	hasBannerImages: Boolean
	hasBannerImages: Boolean
	activeShops: Boolean
	activeShops: Boolean
	past: Boolean
	past: Boolean
	published: Boolean
	published: Boolean
	publiclySearchable: Boolean
	publiclySearchable: Boolean
	upcoming: Boolean
	upcoming: Boolean
	videogameIds: [ID]
	videogameIds: [ID]
}

input LeagueQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: LeaguePageFilter
	filter: LeaguePageFilter
	sort: TournamentPaginationSort
	sort: TournamentPaginationSort
}

input LocationFilterType {
	countryCode: String
	countryCode: String
	state: String
	state: String
	city: String
	city: String
}

input PaginationSearchType {
	fieldsToSearch: [String]
	fieldsToSearch: [String]
	searchString: String
	searchString: String
}

input ParticipantPageFilter {
	id: ID
	id: ID
	ids: [ID]
	ids: [ID]
	eventIds: [ID]
	eventIds: [ID]
	search: PaginationSearchType
	search: PaginationSearchType
	gamerTag: String
	gamerTag: String
	unpaid: Boolean
	unpaid: Boolean
	incompleteTeam: Boolean
	incompleteTeam: Boolean
	missingDeck: Boolean
	missingDeck: Boolean
	checkedIn: Boolean
	checkedIn: Boolean
	notCheckedIn: Boolean
	notCheckedIn: Boolean
}

input ParticipantPaginationQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: ParticipantPageFilter
	filter: ParticipantPageFilter
}

input PhaseGroupPageQuery {
	page: Int
	page: Int
	perPage: Int
	perPage: Int
	sortBy: String
	sortBy: String
	entrantIds: [ID]
	entrantIds: [ID]
	filter: PhaseGroupPageQueryFilter
	filter: PhaseGroupPageQueryFilter
}

input PhaseGroupPageQueryFilter {
	id: [ID]
	id: [ID]
	waveId: ID
	waveId: ID
}

input PhaseGroupUpdateInput {
	phaseGroupId: ID!
	phaseGroupId: ID!
	stationId: ID
	stationId: ID
	waveId: ID
	waveId: ID
}

input PhaseUpsertInput {
	#   The name of the Phase. For example, "Top 8" or "Pools"name: String
	#   The name of the Phase. For example, "Top 8" or "Pools"
	name: String
	#   The number of pools to configure for the Phase. Only applies to brackets that #   support poolsgroupCount: Int
	#   The number of pools to configure for the Phase. Only applies to brackets that
	#   support pools
	groupCount: Int
	bracketType: BracketType
	bracketType: BracketType
}

input ResolveConflictsLockedSeedConfig {
	eventId: ID!
	eventId: ID!
	numSeeds: Int!
	numSeeds: Int!
}

input ResolveConflictsOptions {
	lockedSeeds: [ResolveConflictsLockedSeedConfig]
	lockedSeeds: [ResolveConflictsLockedSeedConfig]
}

input SeedPageFilter {
	id: ID
	id: ID
	entrantName: String
	entrantName: String
	checkInState: [Int]
	checkInState: [Int]
	phaseGroupId: [ID]
	phaseGroupId: [ID]
	eventCheckInGroupId: ID
	eventCheckInGroupId: ID
	phaseId: [ID]
	phaseId: [ID]
	eventId: ID
	eventId: ID
	search: PaginationSearchType
	search: PaginationSearchType
}

input SeedPaginationQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: SeedPageFilter
	filter: SeedPageFilter
}

input SetFilterLocation {
	#   Only return Sets in this state. Only applicable to US statesstate: String
	#   Only return Sets in this state. Only applicable to US states
	state: String
	#   Only return Sets in this country. Expects a valid two-letter country codecountry: String
	#   Only return Sets in this country. Expects a valid two-letter country code
	country: String
	distanceFrom: SetFilterLocationDistanceFrom
	distanceFrom: SetFilterLocationDistanceFrom
}

input SetFilterLocationDistanceFrom {
	#   Point at which to perform distance calculationpoint: SetFilterLocationDistanceFromPoint
	#   Point at which to perform distance calculation
	point: SetFilterLocationDistanceFromPoint
	#   Distance from the point to include results inradius: String
	#   Distance from the point to include results in
	radius: String
}

input SetFilterLocationDistanceFromPoint {
	lat: Float
	lat: Float
	lon: Float
	lon: Float
}

input SetFilters {
	#   Only return Sets for these EntrantsentrantIds: [ID]
	#   Only return Sets for these Entrants
	entrantIds: [ID]
	#   Only return Sets for this Entrant size. For example, to fetch 1v1 Sets only, #   filter by an entrantSize of 1entrantSize: [Int]
	#   Only return Sets for this Entrant size. For example, to fetch 1v1 Sets only,
	#   filter by an entrantSize of 1
	entrantSize: [Int]
	#   Only return Sets that have an attached VODhasVod: Boolean
	#   Only return Sets that have an attached VOD
	hasVod: Boolean
	#   Do not return empty Sets. For example, set this to true to filter out sets that #   are waiting for progressions.hideEmpty: Boolean
	#   Do not return empty Sets. For example, set this to true to filter out sets that
	#   are waiting for progressions.
	hideEmpty: Boolean
	#   Return sets that contain a byeshowByes: Boolean
	#   Return sets that contain a bye
	showByes: Boolean
	#   Only return Sets that are in an Online event. If omitted, Sets for both online #   and offline Events are returnedisEventOnline: Boolean
	#   Only return Sets that are in an Online event. If omitted, Sets for both online
	#   and offline Events are returned
	isEventOnline: Boolean
	#   Only return Sets in certain geographical areas.location: SetFilterLocation
	#   Only return Sets in certain geographical areas.
	location: SetFilterLocation
	#   Only return Sets for these ParticipantsparticipantIds: [ID]
	#   Only return Sets for these Participants
	participantIds: [ID]
	#   Only return Sets in these PhaseGroupsphaseGroupIds: [ID]
	#   Only return Sets in these PhaseGroups
	phaseGroupIds: [ID]
	#   Only return Sets in these PhasesphaseIds: [ID]
	#   Only return Sets in these Phases
	phaseIds: [ID]
	#   Only return Sets in these EventseventIds: [ID]
	#   Only return Sets in these Events
	eventIds: [ID]
	#   Only return Sets in these TournamentstournamentIds: [ID]
	#   Only return Sets in these Tournaments
	tournamentIds: [ID]
	#   Only return Sets for these PlayersplayerIds: [ID]
	#   Only return Sets for these Players
	playerIds: [ID]
	#   Only return Sets for these RoundsroundNumber: Int
	#   Only return Sets for these Rounds
	roundNumber: Int
	#   Only returns Sets that are in these statesstate: [Int]
	#   Only returns Sets that are in these states
	state: [Int]
	#   Only return Sets that are assigned to these Station IDsstationIds: [ID]
	#   Only return Sets that are assigned to these Station IDs
	stationIds: [ID]
	#   Only return Sets that are assigned to these Station numbersstationNumbers: [Int]
	#   Only return Sets that are assigned to these Station numbers
	stationNumbers: [Int]
	#   Only return sets created or updated since this timestampupdatedAfter: Timestamp
	#   Only return sets created or updated since this timestamp
	updatedAfter: Timestamp
}

input ShopLevelsQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
}

input ShopOrderMessagesQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
}

input StandingGroupStandingPageFilter {
	page: Int
	page: Int
	perPage: Int
	perPage: Int
	sortBy: String
	sortBy: String
}

input StandingPageFilter {
	id: ID
	id: ID
	ids: [ID]
	ids: [ID]
	search: PaginationSearchType
	search: PaginationSearchType
}

input StandingPaginationQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: StandingPageFilter
	filter: StandingPageFilter
}

input StationFilter {
	page: Int
	page: Int
	perPage: Int
	perPage: Int
}

input StationUpsertInput {
	number: Int!
	number: Int!
	clusterId: ID
	clusterId: ID
}

input TeamPaginationFilter {
	globalTeamId: ID
	globalTeamId: ID
	eventState: ActivityState
	eventState: ActivityState
	eventId: ID
	eventId: ID
	eventIds: [ID]
	eventIds: [ID]
	minEntrantCount: Int
	minEntrantCount: Int
	maxEntrantCount: Int
	maxEntrantCount: Int
	search: PaginationSearchType
	search: PaginationSearchType
	type: Int
	type: Int
	tournamentId: ID
	tournamentId: ID
	memberStatus: [TeamMemberStatus]
	memberStatus: [TeamMemberStatus]
	videogameId: [ID]
	videogameId: [ID]
	isLeague: Boolean
	isLeague: Boolean
	upcoming: Boolean
	upcoming: Boolean
	past: Boolean
	past: Boolean
	rosterComplete: Boolean
	rosterComplete: Boolean
	rosterIncomplete: Boolean
	rosterIncomplete: Boolean
}

input TeamPaginationQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: TeamPaginationFilter
	filter: TeamPaginationFilter
}

input TopGameFilter {
	#   Array of which # top game you want to filter on.e.g. [2, 3] will filter on the #   2nd and 3rd top gamesgameNums: [Int]
	#   Array of which # top game you want to filter on.e.g. [2, 3] will filter on the
	#   2nd and 3rd top games
	gameNums: [Int]
}

input TournamentLocationFilter {
	#   Latitude, LongitudedistanceFrom: String
	#   Latitude, Longitude
	distanceFrom: String
	#   e.g. 50midistance: String
	#   e.g. 50mi
	distance: String
}

input TournamentPageFilter {
	id: ID
	id: ID
	ids: [ID]
	ids: [ID]
	#   ID of the user that owns this tournament.ownerId: ID
	#   ID of the user that owns this tournament.
	ownerId: ID
	#   If true, filter to only tournaments the currently authed user is an admin ofisCurrentUserAdmin: Boolean
	#   If true, filter to only tournaments the currently authed user is an admin of
	isCurrentUserAdmin: Boolean
	countryCode: String
	countryCode: String
	addrState: String
	addrState: String
	location: TournamentLocationFilter
	location: TournamentLocationFilter
	afterDate: Timestamp
	afterDate: Timestamp
	beforeDate: Timestamp
	beforeDate: Timestamp
	computedUpdatedAt: Timestamp
	computedUpdatedAt: Timestamp
	name: String
	name: String
	venueName: String
	venueName: String
	isFeatured: Boolean
	isFeatured: Boolean
	isLeague: Boolean
	isLeague: Boolean
	hasBannerImages: Boolean
	hasBannerImages: Boolean
	activeShops: Boolean
	activeShops: Boolean
	regOpen: Boolean
	regOpen: Boolean
	past: Boolean
	past: Boolean
	published: Boolean
	published: Boolean
	publiclySearchable: Boolean
	publiclySearchable: Boolean
	staffPicks: Boolean
	staffPicks: Boolean
	hasOnlineEvents: Boolean
	hasOnlineEvents: Boolean
	topGames: TopGameFilter
	topGames: TopGameFilter
	upcoming: Boolean
	upcoming: Boolean
	videogameIds: [ID]
	videogameIds: [ID]
	sortByScore: Boolean
	sortByScore: Boolean
}

input TournamentQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: TournamentPageFilter
	filter: TournamentPageFilter
	sort: TournamentPaginationSort
	sort: TournamentPaginationSort
}

input TournamentRegistrationInput {
	eventIds: [ID]
	eventIds: [ID]
}

input UpdatePhaseSeedInfo {
	seedId: ID!
	seedId: ID!
	seedNum: ID!
	seedNum: ID!
	phaseGroupId: ID
	phaseGroupId: ID
}

input UpdatePhaseSeedingOptions {
	#   Validate that seedMapping exactly accounts for all entrants in the phasestrictMode: Boolean
	#   Validate that seedMapping exactly accounts for all entrants in the phase
	strictMode: Boolean
}

input UserEventsPaginationFilter {
	videogameId: [ID]
	videogameId: [ID]
	eventType: Int
	eventType: Int
	minEntrantCount: Int
	minEntrantCount: Int
	maxEntrantCount: Int
	maxEntrantCount: Int
	location: LocationFilterType
	location: LocationFilterType
	search: PaginationSearchType
	search: PaginationSearchType
}

input UserEventsPaginationQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: UserEventsPaginationFilter
	filter: UserEventsPaginationFilter
}

input UserLeaguesPaginationFilter {
	videogameId: [ID]
	videogameId: [ID]
	upcoming: Boolean
	upcoming: Boolean
	past: Boolean
	past: Boolean
	search: PaginationSearchType
	search: PaginationSearchType
}

input UserLeaguesPaginationQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: UserLeaguesPaginationFilter
	filter: UserLeaguesPaginationFilter
}

input UserTournamentsPaginationFilter {
	past: Boolean
	past: Boolean
	upcoming: Boolean
	upcoming: Boolean
	search: PaginationSearchType
	search: PaginationSearchType
	videogameId: [ID]
	videogameId: [ID]
	tournamentView: String
	tournamentView: String
	excludeId: [ID]
	excludeId: [ID]
}

input UserTournamentsPaginationQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: UserTournamentsPaginationFilter
	filter: UserTournamentsPaginationFilter
}

input VideogamePageFilter {
	id: [ID]
	id: [ID]
	name: String
	name: String
	forUser: ID
	forUser: ID
}

input VideogameQuery {
	page: Int
	page: Int
	#   How many nodes to return for the page. Maximum value of 500perPage: Int
	#   How many nodes to return for the page. Maximum value of 500
	perPage: Int
	sortBy: String
	sortBy: String
	filter: VideogamePageFilter
	filter: VideogamePageFilter
}

input WaveUpsertInput {
	identifier: String!
	identifier: String!
	startAt: Timestamp!
	startAt: Timestamp!
	endAt: Timestamp!
	endAt: Timestamp!
}

directive @deprecated(reason: String) on FIELD_DEFINITION | ENUM_VALUE

directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

directive @publicCache(cacheAge: Int) on FIELD

directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
